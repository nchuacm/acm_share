### RTOJ_1209 - 产生数

[去看题目描述](./description.md)

&emsp;&emsp;这题和[RTOJ_1208](../RTOJ_1208_stxw/description.md)类似，区别是上一题每一层到另一层楼只有两种走法，这题从一个整数有可能变换成多个不同的整数，只需要对一个整数分别枚举所有可能的变换就好了。

&emsp;&emsp;由于整数之间变换是某一位的变化，如果用一个整形变量来实现这种变换会比较复杂，因此可以采用字符串来存储一个整数，这样对整数变换时只需要变化字符串中的某个字符就好了，方便了很多。对于输入的整数n，可以使用字符串`char n[10];`来存储；对于变换规则，可以用`char mp[MAX_K][2];`来表示，在k个规则中，`mp[i][0]`表示使用第i个规则进行变换前的数字，`mp[i][1]`表示变换使用第i个规则进行变换后的数字。

```cpp
char n[10]; // 输入的整数
char mp[MAX_K][2]; // 变换规则

scanf("%s", n);
scanf("%d", &k);
for(i = 0; i < k; i++)
{
	scanf("%d %d", &x, &y);
	mp[i][0] = (char)('0' + x); // 变换前的数字
	mp[i][1] = (char)('0' + y); // 变换后的数字
}
```

&emsp;&emsp;与[RTOJ_1208](../RTOJ_1208_stxw/description.md)类似，需要定义一个搜索用的队列和一个标记数组。

```cpp
// 搜索用的队列
char que[MAX_N][10];
int front = 0, back = 0;
// 标记数组
int vis[MAX_N];
```

&emsp;&emsp;因为整数是以字符串来存储的，所以搜索用的队列中每个元素也是字符串类型的。但是标记数组需要使用整形下标来判断某个整数是否被访问过，因此需要先将整数从字符串形式转化为整形变量才能进行判断，为了解决这个问题，可以定义一个转化函数来实现，代码如下。

```cpp
// 将整数从字符串形式转化为整形变量
int string_to_int(char str[], int len)
{
	int i, num = 0;
	for(i = len - 1; i >= 0; i--)
	{
		num = num * 10 + (int)(str[i] - '0');
	}
	return num;
}
```

&emsp;&emsp;接下来对队列和标记数组进行初始化，将标记数组除输入的整数以外都设置为未访问过，然后将输入的整数入队。

```cpp
// 初始化标记数组
len = strlen(n);
memset(vis, 0, sizeof(vis));
num = string_to_int(n, len); // 将输入的整数从字符串形式转化为整数形式
vis[num] = 1;

// 将输入的整数入队
strcpy(que[back], n);
back++;
```

&emsp;&emsp;然后就可以开始搜索了，每次搜索时，先取队头元素，然后枚举队头元素的每一位数字，用所有的变换规则中变换前的数字去比对，如果某一位与某个变换规则变换前的数字相等，说明队头元素的该位数字可以使用该变换规则变换成另一个整数，枚举完成后就可以找到队头元素只经过一次变换后的所有整数，搜索的过程的代码如下：

```cpp
while(front != back)
{
	char src[10], dst[10];
	strcpy(src, que[front]); // 取队头元素

	for(i = 0; i < len; i++) // 枚举队头元素的每一位数字
	{
		for(j = 0; j < k; j++) // 枚举所有的变换规则
		{
			if(src[i] == mp[j][0]) // 判断队头元素的第i位是否可以使用第j的规则进行变换
			{
				strcpy(dst, src);
				dst[i] = mp[j][1]; // 将队头元素进行变换，变换后的整数存入dst中

				num = string_to_int(dst, len);
				if(vis[num] == 0) // 判断变换后的整数是否访问过
				{
					// 将变换后的整数入队
					strcpy(que[back], dst);
					back++; 

					vis[num] = 1; // 将变换后的整数标记为已访问过
				}
			}
		}
	}
	front++; // 将队头元素出队
}
```

&emsp;&emsp;搜索完成后，所有能产生的整数个数就等于入队的整数个数，而入队的整数个数就等于队尾指针back的值，所以最后输出back作为答案就好了。

[去看参考代码](./main.cpp)
