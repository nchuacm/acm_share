### POJ_1443 - 对称二叉树
&emsp;&emsp;和实验1一样，本题也是一道二叉树遍历题。遍历的大致过程是先判断根节点是否为空，如果为空，返回1，表示是一颗对称二叉树。然后根据根节点的左右孩子是否都为空，或不为空，来判断当前节点是否对称，如果不对称，则该树不是一颗对称二叉树，返回一个0。如果当前节点对称，再判断左右子树是否都是对称二叉树，如果左右子树有一颗不是对称二叉树，则该树不是一颗对称二叉树，返回0。最后，如果以上判断都不成立，说明该树是一颗对称二叉树，返回一个1。因为遍历过程是先访问根节点，再遍历左右子树，所以遍历过程属于先序遍历。
&emsp;&emsp;与实验1不同，这次读入的是二叉树的层序遍历序列，因此使用顺序存储来存储二叉树会方便一些。直接用字符串读取输入的层序遍历序列，读入的第1个字符就是二叉树的根节点，对于第i个字符，其左孩子节点是第2×i个字符，其右孩子节点是第2×i+1个字符。

&emsp;&emsp;接下来进行二叉树遍历，先序遍历大致的过程为：
1. 判读当前树是否为空
2. 访问当前树的根节点
3. 遍历左子树
4. 遍历右子树

```cpp
int search(char tree[], int root)
{
	// 判断该树是否为空树
	// .....
	// 访问当前根节点
	// .....
	// 遍历左子树
	// .....
	// 遍历右子树
	// .....
	return 1;
}
```

&emsp;&emsp;第1个过程，判读当前树是否为空，判断当前根节点的字符是否是'#'就好了。
```cpp
if(tree[root] == '#')//判断该树是否为空树
{
	return 1;
}
```
&emsp;&emsp;第2个过程，访问当前树的根节点，对于本题来说，需要根据当前根节点的左右孩子是否都为空，或者都不为空，来判断当前根节点是否对称，如果不对称，返回0。
```cpp
if((tree[2 * root] == '#' && tree[2 * root + 1] != '#') ||
	(tree[2 * root] != '#' && tree[2 * root + 1] == '#'))
{//判断当前节点的左右孩子是否对称
	return 0;
}
```
&emsp;&emsp;第3个和第4个过程，遍历左右子树，利用递归的方式来遍历左右子树，如果左右子树有一颗不是对称二叉树，返回0。
```cpp
num += search(tree, 2 * root);//查找左子树
num += search(tree, 2 * root + 1);//查找右子树
if(num != 2)//判断左右子树是否有一颗树不是对称二叉树
{
	return 0;
}
```